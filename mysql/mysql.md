# Getting Started

### mysql的知识点
本章节主要介绍Mysql架构，mysql 日志，mysql的mvcc,Mysql的索引，mysql语法，以及优化，执行计划和慢查询日志，主从备份，分布式事务等方面的体系化的讲述

##### Mysql的架构
  mysql分为server层和存储引擎

      server层
      * 连接器：管理连接权限验证
      * 查询缓存： 命中缓存直接换回查询结果
      * 分析器： 分析语法
      * 优化器： 生成执行计划，选择索引
      * 执行器： 操作索引返回结果

      存储引擎
        存储引擎负责数据的存储和提取，其架构是插件式，innodb sql 5.5.5版本开始成为mysql的默认存储引擎。

      各种引擎的对比：
        * innoDB ：支持事务，支持外键，InnoDB是聚焦索引，数据文件是和索引绑在一起的。必须要有主键，通过主键索引效率很高，但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据，不支持全文检索。
        * MyISAM: 不支持事务，不支持外键，MySAM是非聚焦索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的，查询效率上MyiSAM要高于InnoDB,因此做读写分离的时候一般选择用InnoDB做主机，MYISAM做从机。
        * Menmory: 有比较大的缺陷使用场景很少，文件数据都存储在内存中，如果mysqld 的进程发生异常，重启或者关闭机器数据就会消失。

      sql的执行过程

        第一步： 客户端连接上mysql数据库的连接器，连接器获取权限，维持管理连接；连接完成后如果你没有后续的指令这个连接就会处于空闲状态，如果太长时间不使用这个连接就会断开，这个空闲时间默认为8小时，由wait_timeout参数控制。

        第二步： 往mysql数据库发送一条sql,这个时候查询缓存开始工作，看看之前有没有执行过这个sql,如果有则直接返回缓存里的数据到客户端，只要对表执行过更新错作缓存都会失效，因此一些很少更新的数据表可考虑使用数据缓存，对频繁更新的表使用缓存反而弊大于利。使用缓存的方法如下sql,通过SQL_CACHE指定：
            select SQL_CACHE * from table  where xxx=xxx

        第三步： 当未命中缓存的时候，分析器开始工作，分析器判断你是select 还是update 还是insert ，分析你的语法是否正确

        第四步： 优化器根据你的表的索引和sql语句决定使用哪个索引，决定join的顺序

        第五步： 执行器执行sql ,调用存储引擎的接口，扫描遍历表或者插入更新数据。

#### mysql日志
  mysql有两个重要的日志，redolog和binlog,redolog是属于innodb的日志，binlog则属于server层的日志。下面介绍这两个日志的作用：当我们更新数据库数据的时候，这两个日志文件也会被更新，记录数据更新操作。

  redolog又称做重做日志，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录，它在数据库重启回复的时候被使用，innodb利用这个日志恢复到数据库宕机前的状态，以此来保证数据的完整性。redolog是物理日志，记录的是某个表的数据做了哪些修改，redolog是固定大小的，也就是说后面的日志会覆盖前面的日志。

  binlog又称作归档日志，它记录了对mysql数据库执行更改的所有操作，但是不包括select、show这类操作。binlog是逻辑日志，记录的是某个表执行了哪些操作。binlog是追加形式的写入日志，后面的日志不会被覆盖前面的日志。

  数据更新过程
      我们执行一个更新操作是这样的： 读取对应的数据到内存中，——>写redolog日志 ——>redolog状态为prepare ——>写入binlog日志 ——>提交事务 ——>redolog状态为commit,数据正式写入日志文件。我们发现redolog的提交的方式为两段式提交，这样做的目的是为了数据恢复的时候确保数据恢复的准确性。因为数据恢复是通过备份的binlog来完成的，索引确保redolog要和binlog一致。


#### mysql 的MVCC
  事务的隔离级别在此略过，在这里单单只介绍mysql实现事务隔离的原理 ————mvcc(多版本并发控制)。在学习mvcc之前需要介绍快照读和当前读。
      快照读就是一个select 语句，例如
        select * from table
        在Repeatableread（可重复读）事务隔离级别下，快照读的特点是获取当前数据库的快照数据，对所有的commit的数据都不可见，快照读不会对上锁。

      当前读 是对所读数据上悲观锁使其他当前读无法操作数据

          select .... lock in shark mode
          select ... for update
          insert
          update
          delete

          上述语句中，后面三个sql都是给数据库上排他锁（X锁），而第一个sql 是给数据库上共享锁（S锁）。X锁是一旦某个当前读到这个锁，其他当前读则没有对这个事务读写的权利，其他当前读会被阻塞住。而S锁是当一个当前读对某条数据上S锁，其他当前读可以对该条数据也上S锁，但不能上X锁，拿到S锁的当前读可以读到数据但不能改数据。


#### MVCC原理
  innodb 实现快照读和当前读悲观锁的技术就是mvcc，innoDB在插入一条数据的时候会在后面跟上两个隐藏列。这两个隐藏列，一个保存了这个行的创建时的系统版本号，一个保存的是行的删除系统版本号。每开始一个新的事务，系统版本号就会自动增长，事务开始时刻的系统版本号会作为事务的ID,innodb 更新一条数据是设置旧数据删除版本号，然后插入一条新的数据并设置创建版本号，然后删除旧数据。那怎么保证快照读到的是未commit的数据呢？两个条件
      1.innodb 只查找创建版本遭遇当前的事务版本的数据行，即，航的系统版本号小于或者等于事务的系统版本号，这样可以确保事务读取的行，要么再事务开始前已经存在的，要么是事务自身插入或者修改过的。
      2.行的删除版本，要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件记录， 才能作为禅村结果返回。

    而数据库锁也是通过比对版本号来决定是否阻塞某个事务。

#### Mysql 索引
  索引介绍：
  
      索引按数据结构可分为哈希表、有序数组、搜索树、跳表。
        * 哈希表适用于只有等值查询的场景。
        * 有序数组适合等值查询和范围查询的场景，但有序数组的索引的更新代价大，所以最好用于静态数据表。
        * 搜索树的搜索效率稳定，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。
        * 跳表可以理解为优化的哈希索引。

      innodb 使用了B+ 数索引模型，而且是多叉树，虽然二叉树的是索引中效率最高的，但是索引需要写入磁盘，如果使用二叉树磁盘IO会变得很频繁。在innodb索引中分为主键索引（聚簇索引）和非主键索引（二级索引）。主键索引保存了该行数据的全部信息，二级索引保存了该行数据的主键；所以使用二级索引的时候会先查询出主键值，然后回表查询出数据。而使用主键索引则不需要回表。

      对二级索引而言可使用覆盖索引来优化sql,看下面的两条sql
      select * from  table where key =1;select id form table wehere key=1;

      key 是一个二级索引，第一条sql是先查出id,然后根据id 回表查询出真正的数据。而第二条数据查询索引后直接返回数据不需要回表。第二条sql索引key覆盖了我们的查询需求，称为覆盖索引。

      普通索引和唯一索引
          innodb是按数据也来读取数据的，当要读取一条数据时候是先将本页数据全部读到内存中，然后找到对应的数据，而不是直接读取，每页数据的默认大小为16KB.
          当一个数据页需要更新数据时，如果内存中有该数据页就直接更新，如果没有该数据页则在不影响数据一致性的前提下；更新操作先缓存到change buffer中，在下次查询需要访问这个数据页的时候再写入更新操作除了查询会将 change buffer 写入磁盘，后台线程也会定期将change buffer 写入磁盘。对于唯一索引来说所有的更新操作都要先判断这个操作是否为违反唯一性的约束，因此唯一索引的更新无法使用change buffer ,而普通索引则可以。唯一索引比普通索引更新多一个唯一性校验的过程。

      联合索引
          两个或者更多列上的索引被称为联合索引（或者符合索引）。联合索引可以减少索引的开销，以联合索引（a,b,c）为例子，建立这样的索引箱单余建立了索引 a,ab,abc三个索引，————mysql 从左到右的使用索引中的字段，一个查询可以只使用索引的一部分，但是只能是最左侧的部分，而且最左侧字段是常量引用时，索引就十分有效，这就是最左前缀原则。由最左前缀原则可知，组合索引是有顺序的，那么哪个索引放在最前面就比较有讲究，对于组合索引还有一个知识点
              索引下推，假设组合索引（a,b,c）如下sql，
                select * form  table where a=xxx and b = xxx
              这个sql 会进行两次筛选，第一次查出 a=xxx数据，再从a=xxx中查出b=xxx数据。使用索引下推和不使用索引下推的区别在于不使用索引下推会先查询出a=xxx 的数据的主键，然后根据查询出的主键回表查询出全部数据，再全数据查询出b=xxx 的数据，而索引下推的执行过程是先查出a=xxx的数据的主键，然后在这些主键上二次查询b=xxx 的主键，然后在回表

                索引下推的特点：
                  * innodb 引擎的表，索引下推只能用于二级索引
                  * 索引下推一般可用于所查询字段不全是联合索引的字段，查询条件为多条件查询且查询字句字段全是联合索引

                
     优化器与索引

      在索引建立之后，一条语句可能会命中多个索引，这是，酒柜交由优化器来选择合适的索引，优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。那么优化器是怎么去确认索引的呢？优化器会优先选择扫描行数最少的索引，同时还会结合使用使用临时表，是否排序等因素经进行综合判断。mysql 在开始执行sql 之前，并不知道满足这个条件的记录有多少个条，而只能根据统计信息来估计，而估计统计信息是通过数据采样得出来的。

      其他索引知识点

        有时候需要索引很长的字符列，这会让索引变得很大很慢还占内存。通常可以开始的部分字符作为索引，这就是前缀索引。这样可以大大节约索引空间，从而提高索引效率，但这样会降低索引的选择性。

      脏页对数据的影响
        当内存数据页和磁盘的数据不一致的时候我们称这个内存页为脏页，内存数据写入磁盘后数据一致，称为干净页。当要读入数据而数据库没有内存的时候，这个时候需要淘汰内存中的数据页——干净页可以直接淘汰掉，而脏页需要先刷入磁盘再淘汰。如果一个查询要淘汰的脏页太多会导致查询的时间变长。为了减少脏页对数据库性能影响，innodb 会控制脏页的比例和脏页刷新时机。

      
  