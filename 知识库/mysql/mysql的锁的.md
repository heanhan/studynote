---
style: summer
---
### Mysql 中的锁（表所、行锁）
锁是计算机协调多个进程或者纯线程并发访问某一资源的机制。在数据库表中，除 传统的计算资源（CPU、RAM、I/O）的争用外，数据也是一种供用用户共享的资源，如何保证数据的并发访问的一致性，有效性是所在有数据库必须要解决的的一个问题。锁冲冲突也是影响数据并发访问的性能的一个重要因素，

#### 概述
相对于其他数据库而言，mysql的锁的机制比较复杂，其最显著的特点是不同的存储引擎支持不同的锁机制。mysql可以大致归纳为以下三种：

		1.表级锁：开销小，加锁块，不会出现死锁；锁的粒度比较大，发生锁冲突的概率最高，并发度最低
		2.行级锁：开销大，加锁慢，会出现死锁；锁的粒度小 ，发生锁的冲突的概率最低，并发程度也是最高。
		3.页面锁：开销和加锁的时间介于表锁和行级锁的中间；会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。

以下是 三种存储引擎 MYISAM 与BDB、InnoDB的各自对行锁、页锁、表锁是否支持

		MYISAM 支持表锁，不支持 行锁与页面锁。
		BDB 支持页面锁，和表锁，不支持行锁。
		InnoDB 支持行锁和表锁，不支持页面锁。 

#### mysql 的存储引擎MYISAM 下表级锁的锁的
mysql的表级锁有两种模式：共享锁（Tabel Read Lock）和表独占锁（Table Write Lock）

		*	对MYISAM的读操作，不会阻塞其他用户对同一张表请求，但会阻塞对同一张表的写请求。
		*	对MYISAM 的写操作，则会阻塞其他用户对同一张表的的读和写操作。
		*	MYIASM 表的读操作和写操作之间，以及写操作之间是串行（注意两种关系）。

当一个线程获得对一个表的写锁之后只有持锁线程可以对表进行更行操作，其他线程的读、写操作都会等待，直到锁被释放为止。

## MYSQL不同存储引擎下的的锁模式介绍

####  1、MYISAM 的模式介绍（因为 MYISAM存储引擎只支持表级锁）
#####  1. 兼容性
	归纳总结：对MYISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一张表的写请求；对MYISAM表的写操作，则会阻塞其他用户对同一张表的的读写之间的请求；MYISAM表的读和写操作之间，以及写和写之间是串行的（当一线程获得对一张表的写锁之后，只有持有锁的线程可以对表进行操作。其他线程的读、写都会等待，直到当前持有锁的线程释放为止。）

#####  2. 如何加锁
MYISAM在执行查询语句时（select ）前，会自动给涉及的所有表加读锁，在执行更新操作（update、delete、insert）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要直接用 LOCK TABLE 命令给 MYISAM 表添加显式加锁，
给MYISAM表添加显式的锁一般是为了一定程度上模拟事务操作，实现对某一时间点多个表的一致性读取，例如：有一个订单表order ,其中一个还有一个订单明细表order_detail ，其中记录有订单每一个产品的金额小计subtotal,假设我们需要检查这两个表的金额合计是否相等，可能就要执行以下的语句。

	select sum(total) from order;
	select sum(subtotal) from order_detail;

这时，如果不嫌给这两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，order_detail 表已经发生了变化，因此，正确的写法应该是：

	LOCK tables order read local ,order_detail read local;
	select sum(total)from order
	select sum(subtatal) from order_detail
	补充说明：1.上面的例子在LOCK tables 是加了local 选项，其作用，就是在满足MYISAM表的并发插入条件情况下，允许其他用户在表尾插入记录，
	2.在用LOCK tables 给显式加表锁是时，必须同时取得所有涉及表的锁，并且mysql 表并发支持锁升级。也就是说在执行LOCK tables 后，只能访问显式加锁的这些表，不能访问未加锁的表，同时，如果加的锁是读锁，那么只能执行查询操作，而不能执行更新操作。其实在自动加锁的情况下也基本如此，mysql问题一次获得sql语句所需要的全部锁，这也正是MYISAM存储引擎下不会出现死锁的原因，

一个session使用LOCK tables 命令时，给表film_text加了锁，这个session 可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session 可以查询表中的记录，但更新就会出现锁等待。

##### 并发锁
concurrent_insert和local操作（此操作为MYISAM引擎专有，InnoDB无此功能）
上面说只要给表加了读锁，其他的session对该表的写操作将被阻塞，那么有没有办法让其他session也能往里面添加数据。这里我们可以使用local关键字，语法如下：local table 表名 read local。这样在当前表被加读锁的时候，可以让其他session往表里添加记录，但需要配合concurrent_insert全局变量使用。

在一定条件下，MYISAM页支持查询和操作的并发执行。
MYISAM存储引擎下，有一个系统变量concurent_insert ，专门用以控制其并发插入的行为，其值可以为 0、1、2
*  当concurrent_insert 设置为0 时，不允许并发插入。
*  当concurrent_insert 设置为1时，如果MYISAM 允许在一个读表的同时，另一个机型从表尾插入记录。这也是MYISAM默认的设置。如果表的中间没有被删除的行行为，MYISAM允许在一个进程读表的同时，另一线程从表尾插入记录，这也是myisam的默认设置。

#####  MYISAM的锁的调度
前面讲过，MYISAM 存储引擎的读和写操作是互斥，读操作之间是串行的。那么一个进程请求某个MYISAM表的读锁，通时零一个进程也请求同一张表的写锁，mysql如何处理呢？答案是写进程先获得锁。不仅如此，即使是读操作先获得锁等待的队列，写请求后到，写锁也会查到读请求之前，这是mysql认为写请求比一般的读请求重要。这也是myisam表不太适合用于大量更新操作的和查询操作的应用的原因，因为，大量的更新操作会造成查询操作很难得到锁，从而永远处于阻塞状体。这种情况有时候会变得很槽糕，幸好我们可以通过一些设置来调节MYISAM的调度行为。
		*  通过指定启动low-priority-updates,使得myisam引擎默认给予读请求一优先的权利。
		*  通过执行命令 set LOW_PRIORITY_UPDATES=1,使得连接发出的请求更新请求的优先级降低。
		* 通过指定INSERT、UPDATE、DELETE 语句的LOW_PRIORITY属性，降低语句的优先级。

虽然上面3种方法都是要么更新优先要么查询优先，但是还是可以用来解决查询相对重要的应用中，读锁等待严重的问题。
另外，mysql页提供一种折中的方法，，即给系统参数， max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值之后，mysql便暂时将写请求的优先级降低。给读进程一定获得锁的机会。

这里还要强调一点：一些需要长时间运行的查询操作，也会是写进程饿死，因此应用中应尽量避免出现长时间运行的查询操作，不要总想用一条select 来解决问题。因为这种看似巧妙的sql语句，往往比较复杂。执行时间较长，在可能的情况下，通过使用中间表等措施随sql 语句做一定的分解，使得每一步查询能在较短时间内完成，从而减少锁冲突，如果负载查询不可避免，应尽量安排在数据库表空闲时间段执行，比如一些定期统计可以安排在夜间执行。


#### InnoDB锁问题
InnoDB与MyISAM 的最大不同有两点：一是支持事务（Transaction）;二是采用行级锁。
行级锁和表级锁本来就有许多不同之处，另外，事务的引入也带来一些问题。

#####  1、事务（transaction）及其ACID属性
	事务是由一组sql语句组成的逻辑处理单元，事务具有4个属性，通常称为事务的ACID属性。
*  原子性: 事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行。
*  一致性：在事务开始和完成时，数据必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以 操持完整性；事务结束时，所有的内部数据结构（B树索引或者双向链表）也都是必须是正确的。
*  隔离性： 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的独立环境执行，这意味着事务处理过程中的中间状态对外部是不可见的，反之依然。
*  持久性： 事务完成之后，他对于数据的修改是永久的，即出现系统故障也能保持。

#####  2、并发带来的问题
相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多的用户。但并发事务会带来一些问题，主要包括以下几种情况。

	*  更新丢失（lost update ）：当两个或者多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题---最后的更新覆盖了其他事务所做的更新。
	*  脏读（dirty reads）：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这个时候如果B事务回滚，那么A事务读取到的数据是不被承认的。
	* 不可重复度（non-repeatable reads）：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读。也就是说，当前事务先进行了一次读取，然后再次读取带到的数据是别的事务修改后的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。
	* 幻读（Phantom reads）： 事务A 首先根据条件索引得到N条数据，然后事务B 改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+1条数据，这就产生了幻读。

	注：不可重复读与幻读的比较：
	两者有些相似，但是前者针对的是update 和delete,后者针对的是insert。
	区别：前者是指读到了已经提交的事务的更改数据（修改和删除），后者是指读到了其他已经提交的事务的新增数据。


#####  3、事务隔离级别 
    
    *  未提交读取：
    *  已提交读：
    *  可重复读：
    *  可序列化： 隔离级别最高
