## 认识 mysql 的锁定机制

mysql 与其他数据库在锁定机制方面不同，mysql 的不同的存储引擎有不同的锁的机制。

例如 InnoDB 存储引擎支持行锁，也支持表锁。默认情况下支持的行锁。MyIsam 支持的是表锁。

#### 行级锁

行级锁的最大优点：锁定的对象的颗粒度很小，发生锁的资源争用的概率最小。能够给予应用程序最大的并发处理能力。

缺点：由于行级锁的所锁定的对象的颗粒度很小，每次获取锁和释放锁的消耗比较大。加锁慢，也有可能会导致死锁的发生。

行级锁不是 mysql 的自己的实现，是有 InnoDB 的存储引擎去实现的。InnoDB 实现了两种类型的锁，包括共享锁、排它锁。

而在锁定机制实现的过程中，为了让行级锁和表级锁共存，InnoDB 使用了两种内部使用的意向共享锁和意向排它锁。

```
共享锁：允许一个事务读一行数据时阻止其他事务读取相同数据的排它锁。

排它锁：允许获得排它锁的事务更新数据，阻止其他事务获取相同数据的共享锁和排它锁。

意向共享锁：事务打算给数据行加共享锁，事务在给一个数据加共享锁前必须先获取该表的意向共享锁。

意向排它锁：事务打算给行数据加排它锁时，事务在给一个数据加排它锁前必须啊先获得该表的意向排它锁。

注：如果一个事务请求的锁模式与当前锁模式兼容，InnoDB就将请求的锁授予该食事务 ，如果两者不兼容，那么该事务要等待锁的释放。
意向锁时 InnoDB 存储引擎自动加的，对于普通 select 语句 innoDB 不会加任何锁，对于 update、insert、delete 语句 InnoDB 会自动加上排它锁，
```



InnoDB 添加共享锁、排他锁：

共享锁：select * from table .... Lock  in share mode

排它锁：  for update 





### InnoDB 存储引擎的锁定机制



InnoDB 存储引擎支持行级锁，支持事务。事务有一组 sql 语句组成的逻辑处理单元。

事务有四大特性：原子性、一致性、隔离性、持久性。

并发事务会出现一些问题：更新丢失、脏读、幻读、不可重读。

```
更新丢失：两个事务更新同一条数据，但是第二个事务却被中途失败退出，导致两个修改都失败了，这时系统没有执行任何锁操作，因此并发事务蔑有被隔离。
脏读：一个事务读了某行数据，但是另一个事务已经更新了数据，这是一个非常危险的很有可能所有的操作被回滚。
不可重复读：一个事务对一行数据重复读了两次，可是得到了不同的结果，在两次读取的数据途中，有可能在另一个事务对数据进行修改。
幻读：事务在操作的过程中进行了两次查询，第二次查询结果包含了第一没有查出来的数据，主要原因是两次查询的过程中另一个事务插入了新的数据。


```

### InnoDB 行级锁的实现方法

InnoDB 行级锁是通过给索引上的索引项加锁来实现，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 使用的表锁。

### 间隙锁

在更新 InnoDB 存储引擎表中的某个区间的数据时，将会锁定这个区间的所有记录，值得注意的是，在这个区间某个记录不存在，该条记录也会被锁定。这时如果另一个 Session 往这个表中插入一条数据，就必须要等到上一个事务释放锁资源。

InnoDB 使用间隙锁的目的有两方面：一方面是为了防止幻读，如果没有添加间隙锁，其他事务添加区间内的某个不存在的记录时，就会发生幻读; 另一方面是为了满足其恢复和赋值的需求。



### InnoDB 行级锁的优化建议

```
1. 尽量控制事务的大小，减小锁定的资源量和锁定时间。
2. 尽可能让所有的数据检索都通过索引来完成，从而避免因为无法通过检索索引加锁而升级为表锁。
3. 尽可能减少基于范围的数据检索的过滤条件。避免间隙锁所带来的负面影响导致无法锁定需要锁定的记录。
4. 在业务环节允许的情况下，尽量使用较为低级别的事务隔离，以减少因为事务隔离级别锁带来的成本。
5. 合理使用缩影，让 InnoDB 在索引上面加锁的时候更准确。
6. 在应用中，尽可能按照相同顺序来访问，防止产生死锁。
7. 对容易产生死锁的业务，可以放弃使用行锁，尝试使用表锁。
```

